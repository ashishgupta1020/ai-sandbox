<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Taskman Project</title>
    <link rel="stylesheet" href="/styles.css" />
    <!-- Markdown rendering: marked.js + DOMPurify for safe HTML -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
    <!-- Grid.js for sorting/filtering/search -->
    <link href="https://unpkg.com/gridjs/dist/theme/mermaid.min.css" rel="stylesheet" />
    <script src="https://unpkg.com/gridjs/dist/gridjs.umd.js"></script>
  </head>
  <body>
    <div class="container">
    <a href="/">← Back to projects</a>
    <h1 id="title">Project</h1>
    <p id="status" class="muted">Loading…</p>

    <section>
      <h2 class="title-row">
        <span>Tasks</span>
        <button id="btn-add-task" type="button" class="btn btn-icon" title="Add task" aria-label="Add task">
          <svg class="icon" viewBox="0 0 24 24" aria-hidden="true">
            <path d="M12 5v14M5 12h14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" />
          </svg>
        </button>
      </h2>
      <div id="add-task-panel" class="add-task-panel card" style="display:none"></div>
      <div id="tasks" class="muted">Loading tasks…</div>
    </section>

    <script>
      // Utils
      function getParam(name) {
        const url = new URL(window.location.href);
        return url.searchParams.get(name);
      }

      // Minimal JSON API helper for POST/GET returning parsed JSON or throwing on error
      async function api(path, opts = {}) {
        const { method, body } = opts || {};
        const fetchOpts = { method, headers: { 'Content-Type': 'application/json' } };
        if (body !== undefined) fetchOpts.body = typeof body === 'string' ? body : JSON.stringify(body);
        const res = await fetch(path, fetchOpts);
        const text = await res.text();
        let data = {};
        try { data = text ? JSON.parse(text) : {}; } catch (_) { data = {}; }
        if (!res.ok || (data && data.error)) {
          const msg = (data && data.error) ? data.error : `HTTP ${res.status}`;
          throw new Error(msg);
        }
        return data;
      }

      // API wrappers
      async function openProject(name) {
        return api('/api/projects/open', { method: 'POST', body: { name } });
      }
      async function apiCreateTask(name, fields = {}) {
        return api(`/api/projects/${encodeURIComponent(name)}/tasks/create`, { method: 'POST', body: fields || {} });
      }
      async function apiUpdateTask(name, index0, fields) {
        return api(`/api/projects/${encodeURIComponent(name)}/tasks/update`, { method: 'POST', body: { index: index0, fields } });
      }
      async function apiDeleteTask(name, index0) {
        return api(`/api/projects/${encodeURIComponent(name)}/tasks/delete`, { method: 'POST', body: { index: index0 } });
      }

      // App state
      let GRID = null;           // Grid.js instance
      let GRID_COLUMNS = null;   // Columns definition (initialized once)
      // Current data rows (kept in-memory to support in-place updates)
      // Row shape: [idx0, visibleIndex, summary, assignee, status, priority, remarks, null]
      let DATA_ROWS = [];
      // Allowed option values for select editors
      const STATUS_OPTS = ['Not Started', 'In Progress', 'Completed'];
      const PRIORITY_OPTS = ['Low', 'Medium', 'High'];
      let CURRENT_PROJECT = null;

      // DATA_ROWS helpers
      function buildRowFromTask(index0, task) {
        const i = Number(index0) || 0;
        const t = task || {};
        return [
          i,                    // hidden 0-based index
          i + 1,                // visible 1-based index
          t.summary || '',
          t.assignee || '',
          t.status || '',
          t.priority || '',
          t.remarks || '',
          null                  // actions col (placeholder at end)
        ];
      }
      function reindexFrom(start) {
        const s = Math.max(0, start | 0);
        for (let i = s; i < DATA_ROWS.length; i++) {
          DATA_ROWS[i][0] = i;      // hidden 0-based index
          DATA_ROWS[i][1] = i + 1;  // visible 1-based index
        }
      }
      function updateRowFromTask(index0, task) {
        const i = Number(index0);
        if (!Array.isArray(DATA_ROWS) || i < 0 || i >= DATA_ROWS.length) return false;
        const row = DATA_ROWS[i];
        const t = task || {};
        row[2] = t.summary  != null ? t.summary  : row[2];
        row[3] = t.assignee != null ? t.assignee : row[3];
        row[4] = t.status   != null ? t.status   : row[4];
        row[5] = t.priority != null ? t.priority : row[5];
        row[6] = t.remarks  != null ? t.remarks  : row[6];
        return true;
      }
      function insertRowFromTask(index0, task) {
        const i = Number(index0);
        if (!Array.isArray(DATA_ROWS) || i < 0 || i > DATA_ROWS.length) return false;
        const row = buildRowFromTask(i, task);
        if (i === DATA_ROWS.length) {
          DATA_ROWS.push(row);
        } else {
          DATA_ROWS.splice(i, 0, row);
          reindexFrom(i);
        }
        return true;
      }
      function deleteRowAt(index0) {
        const i = Number(index0);
        if (!Array.isArray(DATA_ROWS) || i < 0 || i >= DATA_ROWS.length) return false;
        DATA_ROWS.splice(i, 1);
        if (DATA_ROWS.length > 0) reindexFrom(i);
        return true;
      }

      // Markdown/HTML helpers
      function getRemarksHTML(src) {
        try {
          if (window.marked && window.DOMPurify) {
            if (typeof marked.setOptions === 'function') marked.setOptions({ breaks: true });
            const html = marked.parse(src ?? '');
            return `<div class="md">${DOMPurify.sanitize(html, { USE_PROFILES: { html: true } })}</div>`;
          }
        } catch (_) {}
        return null;
      }

      // Small reusable Markdown editor with Preview toggle
      // createMarkdownEditor(initialText, { onSave(value), onCancel() }) => HTMLElement
      function createMarkdownEditor(initialText, hooks = {}) {
        const wrapper = document.createElement('div');
        wrapper.className = 'md-editor';

        const toolbar = document.createElement('div');
        toolbar.className = 'md-toolbar';
        const btnPreview = document.createElement('button');
        btnPreview.type = 'button'; btnPreview.className = 'btn btn-sm'; btnPreview.textContent = 'Preview';
        toolbar.appendChild(btnPreview);
        // Only include Save/Cancel if hooks provided (editing context)
        if (typeof hooks.onSave === 'function') {
          const btnSave = document.createElement('button');
          btnSave.type = 'button'; btnSave.className = 'btn btn-sm'; btnSave.textContent = 'Save';
          btnSave.addEventListener('click', () => { hooks.onSave && hooks.onSave(textarea.value); });
          toolbar.appendChild(btnSave);
        }
        if (typeof hooks.onCancel === 'function') {
          const btnCancel = document.createElement('button');
          btnCancel.type = 'button'; btnCancel.className = 'btn btn-sm'; btnCancel.textContent = 'Cancel';
          btnCancel.addEventListener('click', () => { hooks.onCancel && hooks.onCancel(); });
          toolbar.appendChild(btnCancel);
        }

        const textarea = document.createElement('textarea');
        textarea.className = 'inline-input multiline';
        textarea.value = typeof initialText === 'string' ? initialText : '';

        const preview = document.createElement('div');
        preview.className = 'md preview';
        preview.style.display = 'none';

        const updatePreview = () => {
          const html = getRemarksHTML(textarea.value);
          if (html) { preview.innerHTML = html; }
          else { preview.textContent = textarea.value || ''; }
        };

        let showingPreview = false;
        btnPreview.addEventListener('click', () => {
          showingPreview = !showingPreview;
          if (showingPreview) {
            updatePreview();
            textarea.style.display = 'none';
            preview.style.display = 'block';
            btnPreview.textContent = 'Edit';
          } else {
            textarea.style.display = '';
            preview.style.display = 'none';
            btnPreview.textContent = 'Preview';
            textarea.focus();
          }
        });

        textarea.addEventListener('keydown', (e) => {
          if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') { e.preventDefault(); if (hooks.onSave) hooks.onSave(textarea.value); }
          else if (e.key === 'Escape') { e.preventDefault(); if (hooks.onCancel) hooks.onCancel(); }
        });

        wrapper.appendChild(toolbar);
        wrapper.appendChild(textarea);
        wrapper.appendChild(preview);
        return wrapper;
      }

      // Build a standalone editor element for a given field type
      function buildFieldEditor(type, options, currentValue, hooks = {}) {
        let editor;
        const commit = (value) => { if (hooks.onCommit) hooks.onCommit(value); };
        const cancel = () => { if (hooks.onCancel) hooks.onCancel(); };
        if (type === 'select') {
          const select = document.createElement('select');
          select.className = 'inline-input';
          for (const opt of (options || [])) {
            const o = document.createElement('option');
            o.value = opt; o.textContent = opt; select.appendChild(o);
          }
          select.value = currentValue || (options && options[0]) || '';
          if (hooks.instantCommit) {
            select.addEventListener('change', () => commit(select.value));
            select.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') { e.preventDefault(); commit(select.value); }
              else if (e.key === 'Escape') { e.preventDefault(); cancel(); }
            });
            select.addEventListener('blur', () => commit(select.value));
          }
          editor = select;
        } else if (type === 'markdown') {
          const mdHooks = hooks.instantCommit ? {
            onSave: () => { commit(editor.querySelector('textarea')?.value || ''); },
            onCancel: () => { cancel(); }
          } : {};
          editor = createMarkdownEditor(typeof currentValue === 'string' ? currentValue : '', mdHooks);
        } else {
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'inline-input';
          input.value = currentValue || '';
          if (hooks.instantCommit) {
            input.addEventListener('keydown', (e) => {
              if (e.key === 'Enter') { e.preventDefault(); commit(input.value); }
              else if (e.key === 'Escape') { e.preventDefault(); cancel(); }
            });
            input.addEventListener('blur', () => commit(input.value));
          }
          editor = input;
        }
        return editor;
      }

      // Grid cell editable wrapper
      function editableFormatter(field, type, options) {
        return (cell, row) => {
          const h = gridjs.h;
          // First hidden column is the 0-based index
          const idx0 = Number(row.cells[0].data);
          // For markdown cells, render markdown preview as the display value
          if (type === 'markdown') {
            const isEmpty = !cell || (typeof cell === 'string' && cell.trim() === '');
            const displayHTML = isEmpty ? null : getRemarksHTML(cell);
            const displayNode = isEmpty
              ? h('span', { className: 'placeholder' }, 'Click to add remarks...')
              : (displayHTML ? gridjs.html(displayHTML) : (cell || ''));
            return h('span', {
              className: 'editable',
              onMouseEnter: (ev) => ev.target.closest('td')?.classList.add('editable-cell'),
              onMouseLeave: (ev) => ev.target.closest('td')?.classList.remove('editable-cell'),
              onClick: (ev) => startInlineEditor(ev.target, idx0, field, type, options, cell)
            }, displayNode);
          }
          // Default single-line behavior
          return h('span', {
            className: 'editable',
            onMouseEnter: (ev) => ev.target.closest('td')?.classList.add('editable-cell'),
            onMouseLeave: (ev) => ev.target.closest('td')?.classList.remove('editable-cell'),
            onClick: (ev) => startInlineEditor(ev.target, idx0, field, type, options, cell)
          }, cell);
        };
      }

      // Renderers
      function renderWithGrid(rows) {
        const box = document.getElementById('tasks');
        if (!rows.length) { box.textContent = 'No tasks found.'; return; }
        // Initialize columns once
        if (!GRID_COLUMNS) {
          GRID_COLUMNS = [
            // Hidden stable index column (0-based)
            { name: '_idx0', hidden: true },
            { name: 'Index', sort: true },
            { name: 'Summary',  sort: true, formatter: editableFormatter('summary',  'text') },
            { name: 'Assignee', sort: true, formatter: editableFormatter('assignee', 'text') },
            { name: 'Status',   sort: true, formatter: editableFormatter('status',   'select', STATUS_OPTS) },
            { name: 'Priority', sort: true, formatter: editableFormatter('priority', 'select', PRIORITY_OPTS) },
            { name: 'Remarks', sort: false, formatter: editableFormatter('remarks', 'markdown') },
            // Actions column at the end
            { name: '', sort: false, formatter: (_, row) => {
                const h = gridjs.h;
                const idx0 = Number(row.cells[0].data);
                const icon = '<svg class="icon" viewBox="0 0 24 24" aria-hidden="true"><path d="M9 3h6a1 1 0 0 1 1 1v1h4v2H4V5h4V4a1 1 0 0 1 1-1zm1 6h2v9h-2V9zm4 0h2v9h-2V9zM7 9h2v9H7V9z" fill="currentColor"/></svg>';
                const btn = h('button', {
                  className: 'btn btn-icon',
                  title: `Delete task #${idx0 + 1}`,
                  'aria-label': `Delete task ${idx0 + 1}`,
                  style: 'margin-left:0',
                  onClick: async () => {
                    try {
                      await apiDeleteTask(CURRENT_PROJECT, idx0);
                      if (deleteRowAt(idx0)) {
                        if (DATA_ROWS.length === 0) { GRID = null; }
                        renderWithGrid(DATA_ROWS);
                      }
                    } catch (e) {
                      alert(e && e.message ? e.message : String(e));
                    }
                  }
                }, gridjs.html(icon));
                return h('div', { style: 'display:flex;align-items:center;justify-content:center;' }, btn);
              }
            }
          ];
        }

        // If a grid already exists, update data in place to avoid jitter
        if (GRID) {
          // Stabilize container height during re-render to reduce flicker
          const prevHeight = box.offsetHeight;
          if (prevHeight > 0) box.style.minHeight = prevHeight + 'px';
          try {
            GRID.updateConfig({ data: rows }).forceRender();
          } finally {
            // Release the min-height after the browser paints
            setTimeout(() => { box.style.minHeight = ''; }, 0);
          }
          return;
        }

        // First-time render
        box.replaceChildren();
        GRID = new gridjs.Grid({ columns: GRID_COLUMNS, data: rows, sort: true, search: true, pagination: { limit: 20 } });
        GRID.render(box);
      }

      function renderFallbackTable(tasks) {
        const box = document.getElementById('tasks');
        if (!Array.isArray(tasks) || tasks.length === 0) { box.textContent = 'No tasks found.'; return; }
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        const headers = ['Index', 'Summary', 'Assignee', 'Status', 'Priority', 'Remarks'];
        for (const h of headers) { const th = document.createElement('th'); th.textContent = h; trh.appendChild(th); }
        thead.appendChild(trh);
        const tbody = document.createElement('tbody');
        tasks.forEach((t, i) => {
          const tr = document.createElement('tr');
          const plain = [String(i + 1), t.summary || '', t.assignee || '', t.status || '', t.priority || ''];
          for (const c of plain) { const td = document.createElement('td'); td.textContent = c; tr.appendChild(td); }
          const remarksTd = document.createElement('td');
          remarksTd.style.textAlign = 'left';
          const src = t.remarks || '';
          const html = getRemarksHTML(src);
          if (html) {
            remarksTd.innerHTML = html;
          } else {
            const container = document.createElement('div');
            container.className = 'md';
            container.style.whiteSpace = 'pre-wrap';
            container.textContent = src;
            remarksTd.replaceChildren(container);
          }
          tr.appendChild(remarksTd);
          tbody.appendChild(tr);
        });
        table.appendChild(thead);
        table.appendChild(tbody);
        box.replaceChildren(table);
      }

      // Data load
      async function loadTasks(name) {
        const box = document.getElementById('tasks');
        try {
          const res = await fetch(`/api/projects/${encodeURIComponent(name)}/tasks`);
          const data = await res.json();
          const tasks = Array.isArray(data.tasks) ? data.tasks : [];
          if (window.gridjs && typeof gridjs.Grid === 'function') {
          const rows = tasks.map((t, i) => {
              const idx = i + 1;
              const summary = t.summary || '';
              const assignee = t.assignee || '';
              const status = t.status || '';
              const priority = t.priority || '';
              const src = t.remarks || '';
              // For Grid.js, pass raw text; formatter will render markdown
              // First column: hidden 0-based index; Second: visible Index; Last: actions placeholder
              return [i, idx, summary, assignee, status, priority, src, null];
            });
            // Keep rows cached for in-place updates
            DATA_ROWS = rows;
            renderWithGrid(DATA_ROWS);
          } else {
            renderFallbackTable(tasks);
          }
        } catch (e) {
          box.textContent = `Error loading tasks: ${e && e.message ? e.message : e}`;
        }
      }

      // Inline editing
      function startInlineEditor(target, index0, field, type, options, currentValue) {
        const td = target.closest && target.closest('td') ? target.closest('td') : null;
        if (!td) return;
        // if an editor already present, skip
        if (td.querySelector('.inline-input')) return;
        const commit = async (value) => {
          try {
            const resp = await apiUpdateTask(CURRENT_PROJECT, index0, { [field]: value });
            // Update in-memory row using server response (source of truth)
            if (resp && resp.ok && typeof resp.index === 'number' && resp.task && updateRowFromTask(resp.index, resp.task)) {
              renderWithGrid(DATA_ROWS);
            } else {
              // Fallback: reload on unexpected or out-of-sync response
              await loadTasks(CURRENT_PROJECT);
            }
          } catch (e) {
            td.textContent = currentValue || '';
            alert(`Failed to save: ${e && e.message ? e.message : e}`);
          }
        };
        const cancel = async () => {
          // Re-render from current in-memory rows to restore cell
          renderWithGrid(DATA_ROWS);
        };
        const editor = buildFieldEditor(type, options, currentValue, { instantCommit: true, onCommit: commit, onCancel: cancel });
        td.replaceChildren(editor);
        const focusable = (editor && editor.querySelector) ? (editor.querySelector('textarea, input, select, [contenteditable="true"]') || editor) : editor;
        if (focusable && focusable.focus) focusable.focus();
        if (focusable && focusable.select) focusable.select();
      }

      // Init
      (async function init() {
        const name = getParam('name');
        const title = document.getElementById('title');
        const status = document.getElementById('status');
        if (!name) {
          title.textContent = 'Project (missing name)';
          status.textContent = 'No project specified.';
          return;
        }
        CURRENT_PROJECT = name;
        title.textContent = `Project: ${name}`;
        try {
          const result = await openProject(name);
          if (!(result && result.ok)) {
            status.textContent = 'Failed to open project.';
          } else {
            status.textContent = '';
          }
        } catch (e) {
          status.textContent = `Error: ${e.message}`;
        }
        await loadTasks(name);

        // Wire add-task button to open inline panel for creating a task
        const btnAddTask = document.getElementById('btn-add-task');
        if (btnAddTask) {
          btnAddTask.addEventListener('click', () => {
            const panel = document.getElementById('add-task-panel');
            if (!panel) return;
            if (panel.getAttribute('data-open') === '1') { panel.style.display = 'none'; panel.setAttribute('data-open', '0'); panel.replaceChildren(); return; }

            // Build form fields using the same editor widgets
            panel.replaceChildren();
            panel.setAttribute('data-open', '1');
            panel.style.display = '';
            const grid = document.createElement('div');
            grid.className = 'form-grid';

            const fields = [
              { key: 'summary',  label: 'Summary',  type: 'text' },
              { key: 'assignee', label: 'Assignee', type: 'text' },
              { key: 'status',   label: 'Status',   type: 'select',  options: STATUS_OPTS, defaultValue: STATUS_OPTS[0] },
              { key: 'priority', label: 'Priority', type: 'select',  options: PRIORITY_OPTS, defaultValue: PRIORITY_OPTS[1] },
              { key: 'remarks',  label: 'Remarks',  type: 'markdown' }
            ];

            const editors = {};
            for (const f of fields) {
              const lab = document.createElement('div'); lab.className = 'label'; lab.textContent = f.label;
              const fieldBox = document.createElement('div'); fieldBox.className = 'field';
              const editor = buildFieldEditor(f.type, f.options, f.defaultValue || '', { instantCommit: false });
              fieldBox.appendChild(editor);
              grid.append(lab, fieldBox);
              editors[f.key] = editor;
            }
            panel.appendChild(grid);

            const actions = document.createElement('div');
            actions.className = 'add-task-actions';
            const btnSave = document.createElement('button'); btnSave.type = 'button'; btnSave.className = 'btn'; btnSave.textContent = 'Save';
            const btnCancel = document.createElement('button'); btnCancel.type = 'button'; btnCancel.className = 'btn'; btnCancel.textContent = 'Cancel';
            actions.append(btnSave, btnCancel);
            panel.appendChild(actions);

            const getValue = (ed) => {
              if (!ed) return '';
              if (ed.tagName === 'SELECT' || ed.tagName === 'INPUT') return ed.value || '';
              const ta = ed.querySelector && ed.querySelector('textarea');
              return ta ? (ta.value || '') : '';
            };

            btnSave.addEventListener('click', async () => {
              const payload = {
                summary: getValue(editors['summary']),
                assignee: getValue(editors['assignee']),
                status: getValue(editors['status']) || STATUS_OPTS[0],
                priority: getValue(editors['priority']) || PRIORITY_OPTS[1],
                remarks: getValue(editors['remarks'])
              };
              try {
                const resp = await apiCreateTask(CURRENT_PROJECT, payload);
                panel.style.display = 'none'; panel.setAttribute('data-open', '0'); panel.replaceChildren();
                // Append to in-memory rows and re-render
                if (resp && resp.ok && typeof resp.index === 'number' && resp.task && insertRowFromTask(resp.index, resp.task)) {
                  renderWithGrid(DATA_ROWS);
                } else {
                  // Fallback: reload on unexpected response
                  await loadTasks(CURRENT_PROJECT);
                }
              } catch (e) {
                alert(e && e.message ? e.message : String(e));
              }
            });

            btnCancel.addEventListener('click', () => {
              panel.style.display = 'none'; panel.setAttribute('data-open', '0'); panel.replaceChildren();
            });
          });
        }
      })();
    </script>
    </div>
  </body>
  </html>
