<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Taskman Project</title>
    <link rel="stylesheet" href="/styles.css" />
    <!-- Markdown rendering: marked.js + DOMPurify for safe HTML -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.1.6/dist/purify.min.js"></script>
    <!-- Grid.js for sorting/filtering/search -->
    <link href="https://unpkg.com/gridjs/dist/theme/mermaid.min.css" rel="stylesheet" />
    <script src="https://unpkg.com/gridjs/dist/gridjs.umd.js"></script>
  </head>
  <body>
    <div class="container">
    <a href="/">← Back to projects</a>
    <h1 id="title">Project</h1>
    <p id="status" class="muted">Loading…</p>

    <section>
      <h2>Tasks</h2>
      <div id="tasks" class="muted">Loading tasks…</div>
    </section>

    <script>
      function getParam(name) {
        const url = new URL(window.location.href);
        return url.searchParams.get(name);
      }

      async function openProject(name) {
        const res = await fetch('/api/projects/open', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name })
        });
        const text = await res.text();
        try { return JSON.parse(text); } catch (_) { return {}; }
      }

      // Grid.js instance
      let GRID = null;
      // Allowed option values for select editors
      const STATUS_OPTS = ['Not Started', 'In Progress', 'Completed'];
      const PRIORITY_OPTS = ['Low', 'Medium', 'High'];

      function getRemarksHTML(src) {
        try {
          if (window.marked && window.DOMPurify) {
            if (typeof marked.setOptions === 'function') marked.setOptions({ breaks: true });
            const html = marked.parse(src ?? '');
            return `<div class="md">${DOMPurify.sanitize(html, { USE_PROFILES: { html: true } })}</div>`;
          }
        } catch (_) {}
        return null;
      }

      // Reusable formatter to attach inline editing behavior to a cell
      function editableFormatter(field, type, options) {
        return (cell, row) => {
          const h = gridjs.h;
          const idx0 = Number(row.cells[0].data) - 1;
          return h('span', {
            className: 'editable',
            onMouseEnter: (ev) => ev.target.closest('td')?.classList.add('editable-cell'),
            onMouseLeave: (ev) => ev.target.closest('td')?.classList.remove('editable-cell'),
            onClick: (ev) => startInlineEditor(ev.target, idx0, field, type, options, cell)
          }, cell);
        };
      }

      function renderWithGrid(rows) {
        const box = document.getElementById('tasks');
        if (!rows.length) { box.textContent = 'No tasks found.'; return; }
        // Recreate the grid each time to avoid layout drift after updates
        if (GRID && typeof GRID.destroy === 'function') {
          try { GRID.destroy(); } catch (_) {}
        }
        box.replaceChildren();
        const columns = [
          { name: 'Index', sort: true },
          { name: 'Summary',  sort: true, formatter: editableFormatter('summary',  'text') },
          { name: 'Assignee', sort: true, formatter: editableFormatter('assignee', 'text') },
          { name: 'Status',   sort: true, formatter: editableFormatter('status',   'select', STATUS_OPTS) },
          { name: 'Priority', sort: true, formatter: editableFormatter('priority', 'select', PRIORITY_OPTS) },
          { name: 'Remarks', sort: false }
        ];
        GRID = new gridjs.Grid({ columns, data: rows, sort: true, search: true, pagination: { limit: 20 } });
        GRID.render(box);
      }

      function renderFallbackTable(tasks) {
        const box = document.getElementById('tasks');
        if (!Array.isArray(tasks) || tasks.length === 0) { box.textContent = 'No tasks found.'; return; }
        const table = document.createElement('table');
        const thead = document.createElement('thead');
        const trh = document.createElement('tr');
        const headers = ['Index', 'Summary', 'Assignee', 'Status', 'Priority', 'Remarks'];
        for (const h of headers) { const th = document.createElement('th'); th.textContent = h; trh.appendChild(th); }
        thead.appendChild(trh);
        const tbody = document.createElement('tbody');
        tasks.forEach((t, i) => {
          const tr = document.createElement('tr');
          const plain = [String(i + 1), t.summary || '', t.assignee || '', t.status || '', t.priority || ''];
          for (const c of plain) { const td = document.createElement('td'); td.textContent = c; tr.appendChild(td); }
          const remarksTd = document.createElement('td');
          remarksTd.style.textAlign = 'left';
          const src = t.remarks || '';
          const html = getRemarksHTML(src);
          if (html) {
            remarksTd.innerHTML = html;
          } else {
            const container = document.createElement('div');
            container.className = 'md';
            container.style.whiteSpace = 'pre-wrap';
            container.textContent = src;
            remarksTd.replaceChildren(container);
          }
          tr.appendChild(remarksTd);
          tbody.appendChild(tr);
        });
        table.appendChild(thead);
        table.appendChild(tbody);
        box.replaceChildren(table);
      }

      async function loadTasks(name) {
        const box = document.getElementById('tasks');
        try {
          const res = await fetch(`/api/projects/${encodeURIComponent(name)}/tasks`);
          const data = await res.json();
          const tasks = Array.isArray(data.tasks) ? data.tasks : [];
          if (window.gridjs && typeof gridjs.Grid === 'function') {
            const rows = tasks.map((t, i) => {
              const idx = i + 1;
              const summary = t.summary || '';
              const assignee = t.assignee || '';
              const status = t.status || '';
              const priority = t.priority || '';
              const src = t.remarks || '';
              const rhtml = getRemarksHTML(src);
              const remarksCell = rhtml ? gridjs.html(rhtml) : (src || '');
              return [idx, summary, assignee, status, priority, remarksCell];
            });
            renderWithGrid(rows);
          } else {
            renderFallbackTable(tasks);
          }
        } catch (e) {
          box.textContent = `Error loading tasks: ${e && e.message ? e.message : e}`;
        }
      }

      let CURRENT_PROJECT = null;
      async function apiUpdateTask(name, index0, fields) {
        const res = await fetch(`/api/projects/${encodeURIComponent(name)}/tasks/update`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ index: index0, fields })
        });
        const text = await res.text();
        let json = {};
        try { json = JSON.parse(text); } catch (_) {}
        if (!res.ok || json.error) {
          throw new Error(json.error || `HTTP ${res.status}`);
        }
        return json;
      }

      function startInlineEditor(target, index0, field, type, options, currentValue) {
        const td = target.closest && target.closest('td') ? target.closest('td') : null;
        if (!td) return;
        // if an editor already present, skip
        if (td.querySelector('.inline-input')) return;
        let editor;
        const commit = async (value) => {
          try {
            await apiUpdateTask(CURRENT_PROJECT, index0, { [field]: value });
            await loadTasks(CURRENT_PROJECT);
          } catch (e) {
            td.textContent = currentValue || '';
            alert(`Failed to save: ${e && e.message ? e.message : e}`);
          }
        };
        const cancel = () => { td.textContent = currentValue || ''; };

        if (type === 'select') {
          const select = document.createElement('select');
          select.className = 'inline-input';
          for (const opt of (options || [])) {
            const o = document.createElement('option');
            o.value = opt; o.textContent = opt; select.appendChild(o);
          }
          select.value = currentValue || (options && options[0]) || '';
          editor = select;
          select.addEventListener('change', () => commit(select.value));
          select.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); commit(select.value); }
            else if (e.key === 'Escape') { e.preventDefault(); cancel(); }
          });
          select.addEventListener('blur', () => commit(select.value));
        } else {
          const input = document.createElement('input');
          input.type = 'text';
          input.className = 'inline-input';
          input.value = currentValue || '';
          editor = input;
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { e.preventDefault(); commit(input.value); }
            else if (e.key === 'Escape') { e.preventDefault(); cancel(); }
          });
          input.addEventListener('blur', () => commit(input.value));
        }
        td.replaceChildren(editor);
        editor.focus();
        if (editor.select) editor.select();
      }

      (async function init() {
        const name = getParam('name');
        const title = document.getElementById('title');
        const status = document.getElementById('status');
        if (!name) {
          title.textContent = 'Project (missing name)';
          status.textContent = 'No project specified.';
          return;
        }
        CURRENT_PROJECT = name;
        title.textContent = `Project: ${name}`;
        try {
          const result = await openProject(name);
          if (result && result.ok) {
            status.textContent = `Opened '${name}'.`;
          } else {
            status.textContent = 'Failed to open project.';
          }
        } catch (e) {
          status.textContent = `Error: ${e.message}`;
        }
        await loadTasks(name);
      })();
    </script>
    </div>
  </body>
  </html>
